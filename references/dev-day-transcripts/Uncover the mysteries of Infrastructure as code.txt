all right so over to your question i've started the recording it started okay so yeah let me just share my screen let me know once you guys can see my screen yeah it's visible okay yeah so i can should we start on we should start right yeah we can start okay yeah so hello everyone um i'll start with my introduction short introduction uh so i'm prashanth uh i have around now uh almost 15 plus years of experience and i've worked on roles like almost all the roles to beyond so right from the development uh till the uh to the upside uh architecture side and all those things okay so yeah it's a fortunate thing that i can work on all those technologies and then around that there are lots of learnings as we do and as we work on those so this is uh my attempt to essentially share those around the infrared character and mainly uh this talk is mainly around the things that i have seen uh generally people will get it wrong okay so that's what i've tried to capture as part of this stack okay so you can see my screen and hear me find it let's start okay so the way i have uh organized this stock uh is into essentially two sections two primary sections uh one is uh it's around the evolution of of the tools and the practices around infrastructure score and the other one is the is is around how the core practices are there and uh what should we follow around so code structure uh and uh how do you manage the inserts report this so all those things so we will talk about that so first section is mainly around tools okay so let's start with it okay so evolution of the instructure practices and those so the first question actually to be honest is why do we even need to know the past okay and what's the point of actually understanding the evolution we can look at the current state and learn from the current state but why do you want to also also see how the things has changed over a period of time and the thing for that is is is to essentially understand why the newer tools or practices are coming up and what they are actually bringing in what are they solving a new problem or is the problem changed so that understanding actually tells you a lot around things and then it also tells you that are you doing anything wrong okay so you look at some of these tools okay this also tells you that what is the right tool for the right job which one uh at least how to think about about these things then in certain places what happens is the previously good practice or the norms basically guess completely changed because of the change in the context and because of that you should actually try to understand what is being changed how the context is changed and then why you end up with a new practices why you end up with new tools and how what they do what do they really bring along with them so before we start uh i want to actually define a term called configuration management okay so configuration management when i'm going to use that in this presentation is basically i'm essentially talking about configuring a server okay it can be a physical server or it can be a virtual machine okay but whatever we are doing in terms of installation of softwares on those machines or we are doing some configuration at the os level okay so all those things uh is basically configuration management okay that's what uh i'm going to use that term throughout guitar so what essentially saying is any os changes then any installation of application runtimes so let's say you need to install java jdk or anything like that or you need to install python runtime uh to basically run the python uh based projects and all those things is all part of the config anything that you do inside a vm or a machine is basically configuration uh so this will also include so if you are if you are running things like uh any supporting application like arabic mq or mongodb or prometheus on either vms or the actual machines what you are essentially uh when you install them on the on the machines you are essentially doing configuration manual okay so that's how i'm going to use that term uh throughout the talk [Music] so let's talk about things uh that are there before even the cloud comes in okay before there was a cloud being used by the organizations organizations almost need to essentially own the infrastructure they need to buy a physical service and maintain them themselves not every organization need to do that there are certain uh there were certain uh companies that essentially uh they are managing this infrastructure for you okay but it is still at the end of the day someone having physical infrastructure and setting up and you essentially have access to access to that and it's a fixed set of machines that are maintained for either for you by some other company or you yourself is managing that so your company itself owns uh the hardware okay so that's how it is uh before the cloud and uh the way in so let's see how the practices were around this so very uh at the very start of the things uh when you have like small number of machines not too many things going on all you need to do is manage everything manually and you can essentially do with that for a few days a few days or as long as you have like manageable things around them but quickly things becomes difficult because of two things one is the scaling and another is the other issues around or doing the changes manually okay so if you are maintaining anything or doing anything manual this is a high risk thing there is always a possibility that you might do things differently the next time and uh then you end up with like completely different setup or completely different configuration on one machine okay and then the one machine doesn't really match the other machine at all and then it works on one of them it doesn't work on the other and then you essentially have the issue of why it's working here and not there what is the exact difference in these machines and the thing is if you do things uh kind of manually then you have to repeat that every time you have to so even if you have a documentation or some some read me or something like that which which gives you the list of commands to essentially follow you are essentially doing that manually again okay and every time you do that if you skip something if you take a different decision at any point of time uh you try to become smart you say that oh this is not this comment is really not required uh because i i tried that last time it was not required so i am going to skip it so if you do something like that you essentially are configuring the machine in a different way now and then it doesn't match and if you do that between the environments then your environments are not matching so it might not fail immediately that is actually a worse part if it fails immediately that's a good part okay but if it doesn't fail immediately then what happens over a period of time these machines are like now are completely different and because of that it might fail in future so something that works in let's say dave or uad will not work in the next environments and then it will be a big headache for you because you you are hoping that you will essentially get this failures in the earlier requirements but if you get it in production that's like a big issue then yeah so different servers will look completely differently because they have changed at different times so all those issues are there so one of the things that you can do is uh is the you reduce the manual effect of it and then you say that instead of me following let's say read me or something i already have these set of things i need to do why can't i use something like a script okay so you the first attempt is essentially you say that i will use a script uh and because it's a script i can reuse it again and again in different uh environments and different machines and that's how i end up with exactly the same thing so this might work for some few things but again the challenge will come in is is that so when you are using the script what the script essentially need to do is it need to understand the current state of of the of the server and then it need to understand the current state and then move it to a desired set okay so you need to apply or carry out certain uh commands to essentially move that uh state current state to the desired state okay that's what this script is essentially so it is completely imperative you decide which steps need to be taken now the issue with this is if if your current state is different okay that means uh your steps to be taken to the desired state will also be different okay so that means that becomes an issue to essentially you might need to you might not be able to use the exact script that you used in some other server because the state of that server was different and the state of these new server is different the current state is different and then you now need to figure out that how do i actually go to the disaster what is is already there what is not already there and how do i essentially do that so current state matters you know in a script and it's an imperative thing so you need to know that which steps i need to take to actually go to the desired state okay one of the thing that you can do uh in in script like that is uh if you need to figure out that do i make do i actually take this step or not take this step is to create steps like that are either item put it so this step itself figures out whether it needs to do it or not so for example if i'm saying uh let's say install java or something like that then you essentially say that instead of just installing java blindly you essentially how intelligence in your script says that is there a java already installed and if it is already there then i will skip that step so all those things you can do there are still issues around if i remove a step then that doesn't corresponds to actually removing java from the infrastructure okay because that step is removed but it is still in the earlier execution that is already installed and then it doesn't really need in terms of removing that thing from the service so all those things are there and there is a possibility of of gap between your automation on the resultant state of the service now uh the other thing that happens is it is very difficult to actually say or talk about the resultant state of the of the machine so uh i cannot say that these are the things are actually applied and this is where this state of the machine is right now and the only way to know that is you need to know what all things were executed on this particular machine so knowing the desired set of something is or knowing the current state of a server is difficult you cannot say that these are the things there unless you verify every step and check that okay these things are there otherwise it is actually difficult to figure out so scripting in a way so it's it's it it helped it's better than uh doing it 10 times manually but you still have issues this okay so people realize this over a period of time and they also realize that this it doesn't really scale and then after this uh certain tools comes in so those are the one that we are talking about are the configuration management tools so things like chef puppet ansible these are the configuration management tools that comes after uh after the scripting now in this case what you are essentially saying is uh you are uh not worrying about the current state of the machine you are saying that this is my desire this is how the machine should look and then the way you define the desired state is is in a declarative you say that these are the things i need uh in my machine okay this is what it should look like and i don't care how do you get there okay so it is up to the tool to figure out how to actually get to the desired state so i don't need to now worry about the current state at all okay the truth will figure out that if this is not there i need to do this do i need to skip some step do i need to carry some step all those things is is part of the of the tools implementation and i don't need to carry those things out then the code because it is declarative it is easier to understand the state of the machine okay what is what what all things are there so you basically can just read through the read through the code and you know that this is what the machine essentially looks like okay and these these tools actually become quite uh successful quite uh famous and they uh essentially are being uh they got adopted a lot okay around this uh if you know that chef puppet is more like a client server architecture too ansible is something that doesn't have it so it's an agent-less implementation okay so ansible doesn't need a agent on the machine in case of clients uh chef and puppet you need a agent on the machine and then you need a server as well which which essentially pushes the changes uh to those machines so it knows that these are the machines where the agents are and it communicates with the agent and sends the desired state okay so those are the things those are the configuration tools and we will see that how they actually change so earlier when they were created uh they were like great tools okay but after uh the context has changed we will see that how they are essentially need to change uh in terms of so most of the tools have added more uh more uh basically features just to address those gaps okay but those gaps were real so we need to understand what to do here okay so it works great all these tools were used but there are still some uh challenges around this one is the configuration drift is still there uh the nature of the hardware was fixed so you have like 10 servers and those are not going anywhere those are like those are there those physical machines sitting there and then what you are doing is you all you are doing is the configuration management all you are doing is to change those state of those machines so even if you are carrying a deployment of your application you are essentially saying that i need to go to this machine or you use a tool that tools goes to the machine and then say that now instead of version 1.2 running on that off of the application running on that machine you change it to let's say a 1.3 or something so you changed the artifact in some way on that machine but this machine is same you reconfigure the same machine again and again to essentially change or perform the deployments okay so over a period of time what happens is it's the machine actually accumulates changes that are done through the automation as well as it will uh it will also accumulate changes that are done possibly manually as well okay and because of that what happens is you do you don't really know whether so if if you have the automation whether that automation is completely in sync with the actual thing or not because people have performed the manual changes there and the physical machine doesn't go away it is already there it is always there okay so automation and gaps between these two essentially are the problem because of the manual changes or any other kind of changes uh due to this okay so if if so in this case what happens is so if if let's say automation is executed it fails for some reason unless a new and you quickly realize while debugging that this is the missing thing uh but you don't have time you need to get the services up and running so what you did is you did a manual fix and uh you said that i we will do or somebody does a manual fix and they basically say that we will update the automation later so if you do a manual fix there what has happened is it's not part of the automation at least right now if you do it if you go and do it that's great but if you miss that or you do it in a different way in automation so all those things are a problem okay so there's a possibility that now if it is running in let's say uat environment it is a mix of because of the automation as well as because of the manual change okay you don't know what is the reason uh that application is now running is it because of the manual change that you did or is it because of the automation okay now if you run that same automation let's say in production at that time it fails because it is it probably have that change but it is done in a different way or probably it doesn't even have that change okay so that's a gap and now if goes and blows up in production and that that's where you lose the confidence on that automation okay and that is probably when you get like afraid to run that automation and if you get afraid to run that automation you essentially more and more things get accumulated manually okay and then you you gap between the automation or infrastructure code and and the actual infrastructure actually widens and that's where the issue just comes in so you are then essentially just uh keeping things running manually that becomes a problem okay now uh uh because of the uh the mixture of things on the physical machines things that are performed through the tooling through the automation and things that are probably done manually it is if you need to create a same machine let's say so you buy a new machine you need to say that this machine should have the same configuration as some other machine then it might be difficult to actually reproduce the exact same machine state through the alternation because you don't really know what are the gaps in that in that case okay so that's a challenge uh uh uh that's where the those were the challenges but it was still the fact that these tools were like uh quite popular and they were really useful for that time okay then more things happened around the uh around the automa around the uh technologies and people started moving away from the physical machines okay so you basically have things like virtualization and you can define software you can define the networking through the software interfaces so what you essentially end up doing is uh you end up with the virtual uh basically the vms rather than physical machines so even if your infrastructure is like four or five machines you can simulate more machines than what infrastructure you have and that allows you to do like isolation of the of these applications and at the same time the same infrastructure is being used uh you know so utilization is basically better in terms of a virtual virtualized environment this also leads to uh the creation of clouds okay so that's where the uh clouds come in and the crowd essentially changed the whole game okay we'll see that how that affects the practices uh before the cloud okay so cloud changed again yeah yeah sorry i'm just saying uh do you want to take questions uh now or do you want everything to be at the end anything is fine are there any questions yeah there's one from rohit singh um right do you wanna do it okay so uh uh on like uh uh for the scripting thing uh we have some uh limitations so there were four three or four bullet points but aren't they all uh uh related to each other so basically previous so they are kind of related to each other yes which one are you talking about this one right and no sorry like uh next the where we talked about chef and puppet so that is not necessarily scripting but yeah so these are like all are related all are like a single point yes yes the thing is you have like static machine or static six hardware okay if you have that then it will accumulate changes because of multiple things on a same machine even if so manual change is one kind of drift another kind of drift is a different automation scripts runs and changes the servers in different ways okay so there are other ways to it's anything that mutates the the uh the machine state you know in a inconsistent way is basically taking it away from the automation and that's where the issues comes in okay so yes there these issues just are related to each other and but somehow for example you cannot it is difficult to produce something from a scratch okay and the reason is you are not doing that every now and then there is no new machine that is there sitting that you are essentially creating again again again okay so you are not essentially practicing it so when you do have a new physical machine at that time you realize that okay there are gaps in the in the uh automation and then i'm not able to essentially say that this this machine is exactly same as the other okay so that's a side effect of the same thing okay configuration so main concept is the configuration does that make sense yeah yeah yeah um i had a question regarding the scripting bit in scripting you had idempotent uh steps right yes yeah so what if what if so um in this basically you said uh if you want to install a specific version of a software let's say java then it will check whether it is installed or not if it is installed then it will skip it what if we what if let's say we want to install a specific version of java let's say we want to install java 11 and java 8 is pre-installed there so will it remove the first it will not depending on your check again okay those are the issues okay so that's why we say that we don't want to deal with this we should have tools that do it for you and the thing is tools are also standardizing these practices okay you are solving the same thing somebody else is following exactly the same thing and then you realize that the entire industry is essentially solving the same thing and then that's where somebody said that okay we need a tool that does it for you okay so that's that's the gap essentially you say that i need this particular version and then you only you check for the version or you check for the java is your implementation if you say i check for the java then i remove everything or reinstall or just basically skip this step altogether but then there are issues now okay so those are the things do you undo do you not undo those are again the implementation details okay yeah i think just to add also i think uh that's a good point i think i also it really boils down to what the essence of declarativeness rights i think it kind of suggests that uh uh if i want a state to be reconciled to a particular version uh and that is kind of makes it very opinionated so when i say that i want version five it means the the module that is going to handle perhaps is going to uninstall if older versions are installed and then restored back into file so but that is something is completely abstracted out for for a guy who's declaratively saying this is what happened yes yes so even if you do this kind of implementation okay looking at a script it is very difficult to know what is there what is not there okay and you also need to know this history of things okay and that's where the issues comes in but if you have a like declarative state that i don't care the concept i just need this is this is my destination and you just say that this is the destination i don't care what your current state is then you you are not thinking in terms of how to actually get there but you are saying you are just specifying that this is where i want to be and then that becomes easier to even understand what is the state of the infrastructure is it also means that do you want to uninstall the older stuff uh whereas like point the new stuff i basically want to just make sure that the new stuff that is being installed uh is being used by by making you point it to the newer stuff without deleting the older stuff so whether you want to prune it or not i think that is also kind of an option that is given in yes and that is again dependent on the tool right so for example in case of so things that are stateless so in case of ansible let's take an example of an ansible if i have a if if you actually have used ansible uh you say that i need this particular i need let's say java of this version present okay that's what you essentially say and then when you execute it it will be looking at the state and say that okay java is not there i will do the installation okay now if you say that i don't want java anymore okay so you cannot just say that i will remove this code what you need to say is you need to say that i want java this this to be absent to start with once you have to say absent then you apply it it basically removes and then next time then you can remove that okay that is because the implementation of answer and they make it clear because ansible doesn't have a state okay it doesn't maintain the state so it cannot figure out that what was the previous code and what is the new code okay so it only looks at this is the code and i need to perform these actions and it also checks that do i need to perform this action or not so you have to be cognizant enough to essentially produce that but if you take an example of something like a stateful thing like a so we are going to talk about that like a terraform so terraform if i remove a code terraform will understand that you remove something because it also maintains a state okay so again there are tools that have handled this in different ways you need to be aware of which tool you are using and how it actually works okay just to extend on that but it must be doing some kind of like dependency management there now so like suppose i am saying that like uh i like i don't want uh this particular uh library okay so then like if some other package is using that then like it would like ansible must be doing that at least so it it would be same huh that again depends on the implementation of module see these tools that are created they are extensible okay that means they have a core execution engine and then there are set of modules that are created now that module implementation need to choose that how they are essentially solving it so in this case i am assuming that it will essentially fail it will say that i cannot uninstall this and this failure is is most likely is coming from the os itself or the way you use apt so apt itself is saying that you cannot uninstall this because it is being used by this particular one does that answer your question so it is it is yes so in a way it will be result into a failure so you have to go and fix it you have to understand why it is actually saying that i cannot do this okay thank you okay so let's move to the cloud so in this case uh we essentially moved from a static set of servers to completely dynamic infrastructure okay uh everything is on demand nothing is pre-created nothing is there when you say that i want to move to cloud nothing is given to you okay it's all on demand and it's all uh it's all provisioned by you no you don't need to let's say call aws and say that okay i need uh four servers please create four servers for me it's nothing like that okay so if you see it's like basically the self-service model you serve yourself and everything is api based so even if you are using aws cli you are essentially calling the apis the rest apis that interns are carrying out the provisioning of machines and everything for you so and you when you provision those it's not like it's taking like two hours to do that it is on-demand and it is within minutes that it happens okay so basically that's why you don't need to pre-order something you don't need to have service running just sitting there just in case you need it's not required okay so it should be basically you can do on-demand information the thing is once you do that okay once you do that once you say that now my instruction is on demand and i can ask for the infrastructure any point of time and it will be given to me then there is nothing there okay and things can come and go okay they are not it doesn't exist forever they will come base essentially you use them they might actually go away okay so that's where the dynamic infrastructure essentially comes in so now you don't really know anything what is running where you don't really know anything okay and that's where the uh so one service that is running that was running on one instance let's say this was the ip address of that and if you remove that machine and recreated it in a recreated it again after a while to install or to run that service again now now this time the ip address is completely different okay so things are now completely dynamic they are moving around so now you need a so you cannot just rely that okay this is the ip address of something i just call this and that's it i am done that's not the case anymore so you need a way to do a service discovery you need a way to do something around this okay you cannot just rely on a static configuration i know that these are the services these are the machines and this is where things are it's not anymore okay so you need a service discovery you need things like private dns you need things like uh load balancers which essentially allows you to send it to the machine so you even if the machines themselves are going away and coming back the load balancer keeps track of what is what need to be getting served under that load balancer so all those things are there so the dynamic things will are introduced now and then you have to deal with it okay uh then it's not only dynamic to be honest so cloud is not only dynamic it is also elastic what do i mean by that is so if i'm doing certain provisioning if i'm if i'm saying that give me certain uh machines okay those machines will be created for you on demand okay but demand is being done by you someone is doing that or someone basically writing a script or running a job or something okay in which the provisioning is happening but now if because everything can be provisioned through the code that means it can happen on the basis of some other things like auto scaling so if the load of these services are like huge then you are adding more machines at runtime nobody is there okay nobody is manually doing it it is being added because of the load on that machine so it can happen at 2 a.m in the morning and uh nobody is actually looking at and managing that infrastructure it's all automatically happening but then once those machines actually comes in okay they need to have the right configuration they need to have the application installed they need to so if my server uh if if there is an application that is running let's say 1.2 version is running then the new machines that are added to handle more load need to have 1.2 running there okay so all those things has to has to be there that's where the elastic nature of the cloud comes in and things are because it is elastic you can you can increase or you can scale out and you can also scale in so things can actually be thrown away so that's why disposable instruction becomes okay you basically just get rid of things that's where you also save the cost okay you are you don't need to pay for uh things that you are not even using so that's where you want to actually do that so that you can reduce the cost okay so so that's why i say that the cloud has changed the game and now let's see the effect of that on the tools okay so now if you see the configuration management so earlier on the configuration management is what we were doing okay because the infrastructure was already there it was all set it's all there okay physically now what you are doing is pre free cloud uh it is you who was was configuring the machine so you any change you need to do either you are doing through pipelines or some other way scripting any tool or anything you are saying that i need to make this change to this set of servers uh and you are performing that and the configuration tool uh let it be safe perpetrator whatever it basically runs it goes to those machines it makes those changes for you and that's what is happening in cloud and the inventory is static so inventory is a term that comes from ansible and inventory is nothing but just set of machines or set of hosts okay so that was static so i know that there are four machines these are the ip addresses of those machines and it's not going to change because those are physically sitting there okay but in case of cloud now we have like different ways to do the configuration because it's a vm i can essentially create a machine image like a hemi or something so that means if i need to create am i a pre-baked ami which has everything installed so java is installed or os is configured or whatever else you need as part of that it's all installed and ami is created that means i am now doing configuration management at real time okay i'm building an ami at that time i am doing the installation of the con of all these things so configuration management is now happening at very time it can also happen at deploy time so when i'm actually adding a server or creating a server let's say set of fixed servers are there so i'm even if i'm on cloud i can actually use the cloud as a fixed set of servers okay it might come and bite you because amazon doesn't guarantee you that your servers or machines will be running forever okay they might actually fail and then you have to replace them once you replace them your automation will not work because once you replace them uh the newer machines will are essentially having different configuration different connectivity different ip addresses so now you need to go into your automation and make and do the changes so in case of ansible if you are maintaining a static set of ip addresses and the one of the machine fails for whatever reason and you need to create a new one you end up with a new ip so you need to go and change the change the configuration to use that new ip everywhere and if your applications are also relying on ip addresses so they are essentially calling a ip address then you need to change all the application configurations as well okay so that's why i'm saying that don't treat cloud as dynamic infrastructure don't treat it as a static infrastructure okay try not to think it as a fixed set of machines it's not it can actually change okay so in this case in case of the deploy time you can use ansible but now see that ansible has a limitation because ansible doesn't have a agent running on the machines in case of chef and puppet actually there is a agent running okay so in a way if you have if you bake that agent as a part of the ami and if you create a new image new instance from that ami the agent can actually go back and register itself against the server so in a way chef and puppet actually have much more dynamic uh inventory or much more dynamic discovery of the infrastructure if a new instance comes in and the agent registers or tells it to the server then chef and puppet knows that there is new machine that is created that i need to consider okay but ansible because it doesn't have agent it is up to you that you need to figure out how do i so if another machine is created you need to because it need to be added in your inventory to be able to do that okay so that means doing so you can do of course there are features added and everything but now think about the auto scaling events if if a load increases and then you are adding more nodes or more machines at runtime and nobody is there there is no deployment happening nothing is happening okay uh but the because of the load is increased let's say cpu is increase or something like that and you want to auto scale things then you are adding more instances those new instances need to have everything configured so either you do it like if you bake everything in the ami it's all there okay but if you want to do a configuration at runtime you can do that so chef and puppet essentially can figure out that there is a new instance created and then they said they sent the configuration to be installed nobody does it because it takes time okay the whole point of creating a new instance is because you want to handle the no load so configuration at runtime is kind of uh avoided you try to do it in in the ami as much as possible but what i'm trying to say here is because of the dynamic nature chef puppet can possibly do that because of the registration mechanism but for ansible you need to have some other mechanism either you use something like ansible gate and you you run it as part of the instance own life cycle okay so once instance comes in uh something like a script that runs at this startup of the instance and that script essentially connects or calls the ansible and fetches the right playbooks to run and then configure the machine so doing uh running ansible at runtime during this scale up uh scale up event is essentially hard so that's what i'm saying the context changes your tools actually usage of the tools changes ansible has something called as a uh ansible tower that does and supports this but an ansible tower is something that is paid okay so all those things comes in uh the inventory is dynamic means the machines or set of machines are continuously changing okay now uh in this case so configuration management is great uh we talked about it and we understand but there is something completely new now okay which is which was not there before which was like infrastructure provisioning okay the machines were already there pre cloud you basically have those machines which you can configure again and again but now there are no machines because machines are required to be created and destroyed because it is possible okay so now you need to think about or you need to solve the infrastructure project there is no infrastructure you need to be creating those infrastructure once the infrastructure is there then you can do configuration management then these tools will actually go and install and configure and boot everything but infrastructure also need to be created first okay so that's where the infrastructure provisioning comes in so that's where the tools like terraform or cloud formation and others essentially comes in so they solve the insertion provisioning uh problem they essentially say that i need these many uh instances or these many machines i need this auto scaling group i need this load balancer i need this route 53 you essentially create as part of of the these tools things like ansible actually added those models okay so it is now like a hybrid tool it can also do provisioning for you okay but it's core was to do the configuration management okay now instance lifecycle management becomes a thing okay earlier you don't need to do lifecycle management of the instance because it was always really running it was always run but now because instance goes away comes back and all this thing you need to think that do i need to do anything at the start of the instance so that's where the runtime configuration comes in or do i need to do something when it goes away okay do i need to gracefully uh turn off the uh the services that are running and handle the traffic accordingly before it gets killed so all those things comes in so in for instance management or life cycle management of the instance when essentially comes in okay so once you have this you is you end up with uh so people realize that earlier we used to do like six set of machines and we configured them again and earlier but now because things are going and coming in we have an option of something completely new thing which is called as immortal infrastructure so as uh as you have like immutable object in a programming language for example uh in java you have extreme or in functional languages you have like everything invertebrate so what you essentially do there if i change this string if i say append something or if i say substring of a string okay what i do or what i get is i get a completely new object okay the earlier object is not changed okay if i don't hold the reference to that earlier object it just garbage collected okay so i can do a substring on a string but i end up with a completely new object i don't really uh the substring is not really changing the original object the original object is if it is still being used it will be there if it is nobody is using it garbage collection will happen and that object was will be destroyed the same thing can be applied to the infrastructure when you say immutable infrastructure what you are essentially doing is any change to the infrastructure is only done by replacement not by in place changes okay so when you make a change you end up with a new object or you end up with a new instance or new thing of that and then the old one is destruct okay so you never change the old one in place you destroy that and you create a new one so then you can do essentially the immutable infrastructure and in this case majority of time you will do configuration at the build time you have the ami uh but uh some so it's always a balance it's always a combination of things okay you probably if you do everything like everything at ami level then for a very small change also you need a new ami okay you can you can do it obviously but you need it okay every time if you choose to do like almost everything at the build time but just certain things are left out at random that also works okay but what you're essentially saying is you are saying you are saying that i am not changing any existing instances i am creating a new instance or completely new one and then getting rid of the world that's what you are doing in a uh ignorable infrastructure so you essentially can do a ami based build type thing you can do a configuration at runtime certain configuration at runtime but this is happening for newer instances not the old one you change by replacing the servers instead of updating them okay uh this helps you to reduce the configuration drift okay so if somebody has made any manual changes to the old machine that machine is now removed completely and the new one is created and the new one is created through automation nobody is creating it manually because the new one is created through automation it doesn't have that change which was done manually so you throw away that and uh and you have the the brand new copy of the same thing okay so it is it helps you to reduce the configuration okay so that's why you essentially say that so i like this code okay this appearing servers is a feature is not a bug okay and this is about the immutable information so uh and this comes from the infrastructure uh sport uh book okay at least the edition one i didn't see that in the edition for whatever you do and the story is something like that you have installed uh uh let's say some server fft server or something and that server is installed on the machine manually by someone and people started using that server but once you do a deployment or you basically recreate the infrastructure you do it by removing the things and recreating your freshwater and once you do that that server is no more because it's created manually so there is no ftp server running anywhere and that is not really a bug that's a feature of the way you are doing the things that's where the immature impression comes okay now the next destruction that is now happening is the kubernetes extension the orchestration platform now everything is becoming moving towards the containers this is like highly dynamic uh even more dynamic than the cloud because it's very easy to actually do things like creation of a of a pod and getting rid of a quad and all that part or container it is completely omittable so you are not you don't even think that you will go inside a docker image and then we'll change the binary or we change the jar or war or something like that you don't think like that in a ec2 instance you will do that but you know in a in a darker image you will never do that you will basically replace you will remove the old docker image and you place it within one so it's like performing these multiple insertions okay build time configuration management uh is what you are doing so docker files is basically like a mi ami is creating a machine image docker files are allowing you to create a container image so you are saying that this is what i need in my i think so in doing the configuration at green time when you are building that image most of the deployments are now getting standardized because almost everyone is trying to use the same tools because of the equivalent uh it's not like that there are like tens or different orchestration platforms that people are using almost everyone is now when you say container orchestration you are essentially talking about kubernetes okay so that helps in terms of tooling and everything everything is kind of getting standardized like public so helm charts is there almost everything that you want to install on a kubernetes cluster you just say help install postgre or help install whatever engine x has installed communities or something like that and it becomes so easy to essentially do that because the platform is known it's standardized people can create tools on top of that and then it allows you to use those tools now things are moving completely on kubernetes like things like operators okay so even if you have uh uh like uh you need to still create crowd-based things like if i need to create a s3 i cannot create it in a kubernetes cluster or if i need to create a root 53 uh entry i have to create aws okay but now what people are essentially doing is they are saying that i will create an operator or a custom resource okay in kubernetes which will in turn manage the cloud communication it will actually create it in the cloud okay but i will not deal with that i will essentially create a yaml file that is created in a kubernetes cluster which in turn is creating the infrastructure for you so that's where the operators are coming in there are lots of things even even there are things like terraform uh operators and things like that so if you see the terraform operator uh it is provided by hashicorp and then now instead of writing terraform code as a terraform thing you are essentially writing is as as if it's a it's a yaml in in kubernetes like a pod or a deployment like that you are writing the terraform resources and then once you do that so this is the example of this workspace okay and then you create all that and you don't need to deal with two different uh tools now so half of the infrastructure is created through terraform and the other half is created through something like helm or uh yamas you don't need to do that you can actually do it extend the kubernetes to essentially do this for you and there are other tools there are other tools uh then there is something that is coming up like uh open application model again this is kubernetes based in which uh people are saying that instead of talking about low level things like infrastructure like i need a plan i need a part i need a service i need an ingress all those things instead of talking about low level things like which objects i need in kubernetes you don't talk about that okay you talk about high level things like i need an application this is how my application looks like and once you you once you talk about that it's the tool that will take care of how to create those things and all these things are done through operators and custom resources so i can give you an example of that so if you see uh so this is open model specification uh which is the cubella is an implementation of it there are other tools as well this is only one of them okay so if you actually see uh the way they are defining they're essentially saying that you define application so like you are defining a deployment or a pod on kubernetes you are actually defining application and here you are saying that that application consists of components one of the component is a web service and this is the image of that web service and this web report runs uh and i need a index so you essentially said everything that for this you need like multiple different yammers just to specify this in government but now you are saying it at one place and you can also give like more dependencies on that so it's one need not be only one component it can be more compromised okay so they are supporting kubernetes they are supporting uh terraform they are supporting end components so that's where the things are moving now and you need to be aware of why things are moving there and why the new tools are being created so that's where the context comes from [Music] okay so that concludes the evolution of things are there any questions um there's nothing in the chat um does anyone want to ask something directly okay if there's nothing we can move to the next set of things okay so now we actually talk about the infrastructure we understood the tools to some extent uh we understood the nature of the how the infrastructure has changed how the uh how the things actually evolved now let's talk about the instructor ask for and what i have seen majority of time people get it wrong okay so we say that almost every one of us understands when we talk about infection we specify the state of the infrastructure as passport so almost everything is essentially good so your infrastructure is for your configurations for your pipeline circle even the policies and etcetera etcetera all all of them are poor and it makes sense people do understand this okay and all code is in version control so you essentially put it in in git and apply the same practices that you apply for application code okay and you know because you put it into a version control you essentially can see every change you can track every change who is what change why it was made and how the code actually evolved over a period of time and you can also go back and go to a previous state of the things okay but i have still seen that people actually get things right on application side but get it wrong on the infrastructure okay and i will give you an example of some outputs so if you see the way we we deal with the code and the configuration of of anything uh most of us are now uh aware of what the 12 factor app is and in case of 12 factor app there are certain things uh guidelines for the code and the configuration of the application okay so this talks about application but what i'm trying to say here is it also is applicable in terms of the infrastructure code as well you get the same set of if you follow the same set of practices you get the benefits of that okay so what uh what do the info actually talks about in terms of uh code base and in terms of the configuration so if you talk about the code let's talk about the code first what you are essentially saying is the same code it is tracked in a version control okay and the same code is getting deployed into multiple advantages okay now when you say that same code is getting deployed into multiple environments it's not exactly the same code that is going a version of that code is actually going okay what do i mean by that is production might be running an older version than what is running in in on staging or then what is running in development environment okay but it is still and those versions are still created from exactly the same code base it is not like a different code okay version in this case is just a snapshot in in a time okay in the past just a snapshot of the of the code in past okay it's not a different code okay so that's where the version is okay that's how we are doing it and we are all doing it for the applications it's not a new thing okay so this is uh one thing and then there is something called as a configuration okay now if you see the 12 factor app configuration is something that is kept outside of the core it is not part of the uh it is not part of the artifact it's not part of the jar it's not part of the uh the build or artifact that you create okay then how do you actually create and deploy something how do you create how do you create a release that you want to deploy in an environment so how do you do that you essentially say that this is my build and this is my config of this environment i mix that together and that's what constitutes a release okay that's what uh constitution needs and that's what you're deploying in the end so uh you however so if you are like using something like a spring application you have a jar or you have a docker image or something like that which is the build and then you have a application configuration site so a config file for that particular environment okay and then you marry them together and that's becomes the deployable that you want to deploy in the environment okay that's what you're essentially doing so to actually simplify and to to put it in perspective you can think it like this this is what is happening so you have so and you applied for the infrastructure as well that's what i'm trying to say here so you have a internship code and there are versions of those infrastructure created as i said the version is just a snapshot in time okay it's not a different code this is basically a snapshot in time okay and then that a particular version is used and it is it is combined with the configuration of that environment to essentially generate a release for that environment okay uh so in this case we are saying that the version v3 is is combined with the dev configuration to generate a diving one our version v2 is combined with production configuration to generate a uh production environment now production rings okay so that's what uh you are essentially doing that's how you are generating the specific uh or release or specific uh deployable okay so i so it's it's a standard practice in terms of application code okay but i have seen that majority of time people get it wrong in the infrared for whatever reason people think that almost everything in infra is conflict and it's specific to a uh to a environment which is not really the case okay and then that leads to all kinds of problems like duplications uh that leads to problems like uh uh it's not having standard environments your environments looks completely different so all those things happen so let's look at some so this is the summary of what we talked about we said that code is same for all the environments okay there is a single code it's not separate configuration is different per environment every environment has different configuration okay you basically have different configuration then code has a version and you deploy a particular version uh in in a in our environment uh there is no versioning required for configuration configuration is always latest but it is tied to a and one so in case of configuration you are actually making duplicates every environment has different configuration okay they need to be same in terms of the thing but physically they are different copies okay and that's what you are doing and you always use the latest there is no versioning required for the configuration now in this case most of the time you will have overrideable defaults so application might have some configuration code the build or artifact which you create might have some configuration code which you can which which basically gives you a defaults and then you how to override them uh uh for a environment okay so that is possible okay but certain things doesn't even have a default value like uh url to let's say database doesn't have a default one you need to know that what is the url of of the database in dev environment which is completely different what is the default in that case okay uh then you need to have a different database in production and that url will be different so you essentially need to have different configurations for different environments okay sometimes you will have defaults so like thread pool size is probably will have like 100 100 uh threads in in my thread is the default value that you might not need to override you know in a different mode you might need to override it in a production you want so in this case it becomes overrideable default okay uh so that's that's where it is uh the configuration is separate for environment but the code is is uh is same and a version of a code is used so this allows you to do things like uh if you if you need to perform a change uh so let's say i'm running something on production uh and uh i'm right now running three instances in production okay and i instead of three instances i want to change it to five instances okay now i if i want to do this change it shouldn't i i shouldn't i need not release a new version of the code okay my code that is running is still exactly the same it should be same okay all i need to do is change from three to five okay and you think that is it possible in your case if you need to do a code change and release a new version then your configuration is not sitting outside of the code okay it is coupled with the code and because it is part of the artifact or whichever code that you are maintaining uh that's why you have to do this okay uh so that's that's where the things comes in if you keep it outside and then all you need to do is change the production configuration the code is exactly same all you are saying is instead of three run five and then you apply that uh you essentially change that thing now also see that you are using the version of the code not the exact code okay that means even if somebody has changed the code in the meantime that doesn't affect you because you are not using the latest code you are using a version of a code okay so that's where the things comes in that's where you should be able to perform these things okay so if i move to the next thing so let's look at some violations that actually violates this thing okay and unless you check so you might be thinking that oh we we actually understand this and we do this but i have seen people actually violating and do not realizing that they are actually violating this basic things so if i go to one of the violation so in this case i have like environment specific code okay environment specific branches or so it can be a folder it can be branches i have seen it in in terms of branches so that's why i've shown it in the branches so in this case you are saying that my dev environment uh essentially have the code and the concept so it might be terraform code it might be helm charts it might be whatever okay but it it it is there and it has everything so entire hem chart is there for that service so if i have like five services there might be five helm charts there might be one health chart deploying all five of them but it is for the dev environment okay then you have a separate one for puberty then you have a separate one for production now in this case if i need to make a change so five is like modest value but if you are like 15 services or even more than that or even less than that if you need to make a change in in in all of those you have to do like 15 services you have to change at first 15 places depending on how you are managing that code and then you have to do that three times for per environment so you will like duplicate almost everything but what you are essentially said here is the entire hem chart or entire terraform code is a configuration because it is specific to a environment but that is not the case okay there is a element of code that can be standardized that is a core and then there is a configuration okay so certain things are configuration certain things are code you want to separate that out ideally the code should be only mentioned once and that way you will avoid the duplication and you also make sure in this case because in this case what happens is your dev essentially can look completely different than your uat or our production okay it potentially can and if you want to keep them safe in sync it is like a tremendous effort on your side how to keep that in sync okay so this is one possible vibration that you can see then there is another violation is you do realize that that you are actually duplicating a lot of coding in here okay then you say that okay i will have a like a shared code which might be a module or which might be something so terraform module is there or it might be helm chart or something like that and then all these uh the environment specific things the ascension just using that the same code what is the issue here so you you are not having good tickets so what is the issue here i am assuming uh yeah what is the issue possible issue here so there is the issue what could be i'm highlighting here any guesses [Music] okay so what is the issue is uh if you are using the same code okay and not the version or the snapshot of the code basically you are not using a version in different environment if i make a change in the shared code that is visible to almost everything so if i make a change in that code in the shared code it is visible to production uh as well okay so if if i need to make a production change that i said from three to five instances if i do that at that time the new code if i if somebody is working on the changes to the infrastructure code those will be visible during that time because i am not using the snapshot in time i'm not using a version i'm using exactly the same code okay that's where the issue is also comes in so you need to also have versions in place so i have seen this as i have seen people having terraform models that are referred through paths okay and but it's not using version at all okay so what could be a non-violation question i have just have one question so on previously uh when we say version we can have use tags as a version right it's not necessary to talk about that yes okay yes okay okay okay so uh non-versions is something like uh so your tool can essentially support a versioning strategy for you okay so there are terraform modules have a versioning support uh help has virginia support and there are other things that also might have version support whichever you are using so tool itself gives you so if depending on which tool you are using it might actually give you an ability to actually version something so in case of terraform you can actually use a terraform register or you can even use git tags to create a version uh in case of helm you have a helm registry in which uh if you put put in the uh the chart it can have a version okay and then all you are doing is you are referring to that version in the module and then you are you are combining it with the uh environment specific configuration and then deploy them so this is one possible way of doing it you can also use git tags in case of uh things like terraform and things that then the another way of doing that is you can also use branches for versioning okay but in this case the way you are using the branches is completely different okay you are using branches here not as a long running branch you are using a branch as a snapshot of snapshot in time of the previous of the master branch that means these branches are short-lived they are created for few time and then they are recreated when you create a new release the old one is deleted and essentially you are creating a new snapshot of the branch okay this strategy will allow you to also perform bug fixes if you want if you need to if you are if your international code is like extensive if you are doing something like operators and kubernetes and you are actually writing code okay and it's a complex code then you probably want to do that because then you can do bug fixes here okay and then because you are going to destroy that uat branch the next time you need to create a new new thing you have to obviously merge back any bug fixes that you would but the only thing you do in in branch likelihood is the bug fixes you are not doing anything new okay and every new release that you need to create you are creating the snapshot of master at that point of time okay so it's it's still a version in a different way it is still a snapshot in time okay and in this case you can see that production doesn't have a branch so essentially what you are saying here is any change that you need to promote to production is essentially going at least through you right okay that's what you're saying so if you want like a separate branch for production you can do that and that directly goes to production but i have seen that people generally at least put it in one other environment before they put it into production so essentially that's what you are seeing here okay and the configuration is coming from is basically specific to the environment it's coming from the world so it's not uh it's it's his latest basically that's what i'm trying to say so branching can also be used but it has to be used as a snapshot in time rather than a long-running branch which is completely living its own life and completely different than where it is created from okay so that's not the case here so now there are cases in which you your tool might not even allow you to do what it doesn't support that okay so what will you do in that case so there is always a possibility that you can use something like get tag okay so in this case cops actually allow you to do cluster templating but it doesn't give you an ability to do a versioning so i cannot basically say that this is the state of the cluster but in production this particular version of the state of the cluster is running okay at least not from a point of view of cops okay cops doesn't give you ability to do version like it like terraform gives you modern modern versions or helm kingsview versioning of the chart cops doesn't give you that cops gives you ability uh templating but doesn't give you the versioning ability so in this case what you're essentially saying is you are checking out a particular version of this particular file only this file is is different it is taken from this version the rest of the things are coming from master okay only this file is coming from a tag okay so you are essentially got a a template from a particular tag and rest of the things are from master so what all what other you are taking from master so when you say that toolbox template and you are saying that this is the template and these are the values so values in this case is is the configuration and you can see that it is taking the values of the dave environment okay so this is a day of environment latest values this is coming from master okay so this is latest but the the tag is coming the template is coming from attack so it is version okay so configuration is latest but the code is version and that's what you are marrying together to essentially create the cluster state that you want to apply so this becomes the amount so this is no more template this is a template the placeholders are filled up by the values and then you end up with a completely uh complete state of the cluster that you want to apply okay that's what you are saying here does that make sense yeah yes yeah so just to summarize uh the code versus configuration thing what we are essentially saying is uh used for models with uh with versions either through registry or to get tags or whatever if you are using helm chart use the uh chart registry use the versions you can also see git tag you can use almost every universal pocket so you can always use that then uh use the if you are using ansibles or roles transfer roles use that again with the versions if you use something like galaxy okay and simple galaxy if you use a galaxy role it comes with a version okay but then when you create your own roles you forgot to do that you do not do versioning and that becomes a problem okay then any change that you do for development is also visible in the production pipeline which is the problem then cops template you can do that versioning as i showed you also some you also might want to do versioning on the deployment scripts so we write like smaller scripts in for for jenkins or something like that if you do that you might also want to if it's like that script is like complex enough and any change in that script might affect the production pipeline or any other environment pipeline then you might also want to do the virgin market and you use a snapshot of that of that deployment script in time okay so this concludes the code versus configuration thing uh and this i have seen people numerous time getting it wrong uh so are there any questions on this is it clear i have a question around i have a question around what actually uh how do you derive or how do you actually decide what constitutes uh basically a release of an infrastructure support with like when you have code and the different environments as configuration so now if you have uh uh so the infrastructure is it is it are you saying that infrastructure as a code should be treated as virgin but not the configuration yes configuration is not one so i can give you an example of helm if you have used it okay so if helm chart is there let's say there is a public health chart for uh something like engine x okay so engine exam chart is there what they are doing they are essentially created a chart and that chart has a version so every time they make a change they change the version of the chart now when when you take that chart and when you try to install that chart what you are essentially doing is you are creating a release of that of that chart okay you are creating a release and that release is a particular installation of that chart i can use the same chart and install it 10 times okay every every 10 things that i have now did when i installed 10 times i've created 10 releases of the exact same chart okay and every time when i do helm install i can actually give a different value sign okay i can say that i want to install exactly this chart but these are the configuration of that chart i want to install and now i can i can install that engine x 10 times with a 10 different uh configuration okay in the same environment but the code or the chart is exactly the same and i'm using exactly the same version of that does that make sense oh yes yes yeah so that's the that's the release when you are installing that you are essentially saying the exact same chart and then you are giving the value so that constituted yeah okay okay so let's talk about some more things that you might or might not have faced depending on the context depending on size of the practice that you're doing so if you are managing like lots of code lots of teams and you are part of a big organization you might face some of this you might not have faced some of this okay but it's a good thing to know that these are the trade-offs so let's quickly talk about that so github's is something that is getting uh popular uh nowadays of course there are again certain people who are now saying that they are moving away from it as well but yes um majority of us are looking at it and it makes sense to some extent so in this case what we are saying is uh git as a source of truth so it becomes the input for the infrastructure basically captures the entire infrastructure so it's in a way uh it is same or similar to in factory sport because you are capturing that but it takes it to one level above uh in a way that so if you want to actually say that everything is is in getting it is the input then in a way you are saying that there is no uh there is no builds that requires a parameter okay so build with parameters essentially goes away or there's no manual builds because i will almost never trigger a manual build i will make a change in the code that triggers that build okay but i don't need to trigger a manual bit of course take it with a pinch of salt is not practical like 100 of that there will be situations but it's a way of thinking have you captured almost everything there so for example in case of build with parameters uh you can do it for some of the parameters but for some of the parameters you can't do it like secrets or something some sensitive information so you might not want to put that in a code so that's what i am saying that thinking is more important rather than actually applying it you are consciously saying that why am i not doing this but you still understand what uh what people are trying to say when they essentially talk about get as a source of truth or or so or the source code and so forth okay now the next thing uh in terms of the github practice is uh you are trying to keep the infrastructure and the state of the kit in sync continuously okay it's not only when someone has is making a change okay so you make a change and then you apply something on the infrastructure that is not the only time when you actually make changes in the intro you are continuously trying to see that there are any changes or any drifts between those two so for example if i make a change in the code and apply it now infrastructure is updated and then i go to the infrastructure and let's say change something manually okay in ideal scenario of a git of operation it should detect that it should basically say that oh there is something that has changed and that is not as per the uh as for the state of the gate okay uh so again in this case there are two flavor two ways to essentially do that you have a mechanism to completely revert to the change that was done manually or at least you have a mechanism to notify that there is some issue okay so somebody can actually go and see that what has happened and how do i restore it back to the state so that's uh that's what is happening in terms of detox and in general it's a good practice to actually do some kind of some kind of continuous or frequent update of the infrastructure to ensure that the state of the infrastructure and and the state of the code is is in sync even if you are not doing the talks then things like github is essentially introduced or quite popular because of kubernetes okay and the way kubernetes works so in this case uh kubernetes majority of tools that you will see is based on kubernetes and the way kubernetes does this is uh in case of operator they essentially do a pull rather than a push so when you make a commit you trigger a pipeline okay that's the general uh that's the general way of doing things but in case of kubernetes and the operators you essentially say that you make a change and somebody actually pulls that change into the infrared and the reason you do that is uh because those those operators or the tools are already running as part of your kubernetes cluster you don't need to provide external access they already have access to kubernetes so nobody need to make a change to the cluster they make the change to the cluster themselves okay and so that's a secure way of doing it because then you are using the uh security model that is given by the kubernetes itself okay so that's uh that's the way uh gitoffs is essentially being used but as i said uh in general even if you are not like on kubernetes or not using uh the tops it is it is still makes sense to uh frequently add or simply apply uh the configuration or the instructor uh code to the infrastructure to just ensure that instructor hasn't gone out of sync with your code okay because sometimes what happens is if you say that only on change we will apply the change then it might be like a long time it might not get applied at all and then if somebody has made a manual change there it's almost never detected even if it's a immovable infrastructure you are not actually replacing anything you are not even running the uh the pipelines or things like that that means that manual change is still sitting there okay and people start relying on it then it is it is essentially you need to be there and once then you run the uh the automation everything goes away and then you lose all the work that was done so it makes sense to essentially apply these changes frequently so that you have these thinking of the infrastructure and the code now uh other things around updates and things like that is if you are doing updates uh at dmi level or certain other things then do it at the entry level do it at the free time of the ami or do it at the first uh environment or things like that and then then lock them up so never say that so for example in a docker we say that never say docker latest okay so that's a that's a very practical thing you should you should never say latest but at the same time uh for for a first environment of our during the build time you should actually try to figure out what is the latest version and should i should you use that version okay so you can essentially use that version for the first environment and then fix it there so that the next versions essentially use the same one and you know that it is already tested it's not a surprise in in a later version so it's already tested in previous versions so you know it works but at the same time you're also getting the updates okay so it makes sense have some strategy around that or to do it okay now the next thing i have seen is if and especially when developers themselves are writing search record uh they create modules of the of the infrastructure that are highly configurable okay almost anything can be changed anything is everything is parameterized and i can use that to essentially configure all almost ability so that is great if that code is like a public uh thing so if i'm writing a public health chart or if i'm writing a public terraform module then i will try to have as much configurability as possible i will parameterize almost everything so that different people can use it in different ways okay but if you are using uh if you are doing it for your own team then you have to think that what i do i allow as a different thing in different environments okay so for example uh if you say that my ami is is is a parameter okay that means potentially you are saying that i can have a different ami uh in let's say uit which is not even tested in in dev okay that's what you are essentially saying so that means the same thing you can do in production as well somebody can make a change and put in a wrong ami in production and blow up the the deployment that is happening and that's the problem so you need to be aware that what you're doing so even if you are using a highly configurable uh module that somebody has created either within the industry or either within your organizations or or basically you're using a public or a public module or something then you have to wrap it in a way that it is still standardized certain things are locked down and the only way to change them is to by having a new version of the code and not through the configuration so that way you essentially control that what is allowed to be changed between environments and what is not and that's important thing and you need to be aware of this trade-off when you write modules uh think uh things that you need to keep in mind is like name collisions create before destroy that is about scrolling deployments uh create before destroy only applies in terms of state less applications in a stateful applications the ruling updates happen differently but yes you need to be our you need to be thinking about these things when you create a removable module okay then you have to handle the shutdown gracefully so as i said that life cycle management offering systems is important then you also if you are if you need to do things like dynamic environments okay then you really need to have a naming strategy okay so if you say that i need to create a test environment on the fly okay it should come it should come up it should run the test and should get destroyed and i want to use uh something like a dev environment so same day environment should be used for for that particular environment so in that case you can use something like a terraform workspaces and things like that but then uh you are naming need to use the name of the workspace naming of the of the of the infrastructure need to do that otherwise you will end up with name clashes it will clash with the development environment in that case okay so if i'm creating a s3 bucket unless i have a way to essentially separate out the workspace s3 and and dev s3 i cannot create those two okay or or similarly any other sql or something like that so you need to have a naming strategy because understand that when you are creating a module there is always a possibility that the same model will be applied multiple times so you cannot have a fixed names in the model and i have seen this uh happening in in the code and then people essentially they need to later on change that it might get becomes difficult to do that later on uh you have to because it's already applied into infrastructure so how this strategy is in place while creating the models the module by definition can always be applied multiple times like i said if you have a health chart i can install it 10 times but if that help chart is creating the same deployment i cannot essentially install 10 times okay because there isn't same resource already exist so there are kubernetes will say that this part or this deployment already exists i cannot create a new one so that's uh that's a problem then there is a point about the output values uh it will again come in the next slide so i will talk at that time the last thing i have this is i think the last thing after that so last thing i have is around the modularity and orchestration okay so modularity is something that you want okay you don't want like a very big code that manages everything in an environment or even multiple amounts you don't want that you want a small [Music] modular code base that allows you to change things independent of each other so for example if there is an issue in my elastic search code so if i am creating a i have a model that essentially creates a elastic search cluster and there's a issue there it is failing for some reason that should not stop me from making a change in let's say postgre cluster or something somewhere else okay so i should be able to perform these things independent of each other it shouldn't couple each other okay but if you manage everything together it's all part of the same code uh because it is failing for elastic search and if i try to apply that change uh it will essentially try to do the changes that i want for the post gray as well as it will try to do it for elasticsearch because you search it out of sync it will stop me from even performing the other changes so this is because of the coupling between these two models so you need the the modularity but at the same time you need to understand what you are using if you are like having modularity what you are losing is the orchestration so what do i mean by orchestration uh when you say that i have different modules you need to know in which order you performed the creation of those modules okay so if there are any dependencies between those three if you need to create a new environment you need to know those dependencies so either you do it like through some some way of managing those dependencies in a document or something so for example if i create uh uh if i create a instance also if i create a uh let's say cluster that postgre cluster need to create in a sub in a subnet okay but the subnet is being created by a different body then i need to know that which module is actually creating this exact subnet that is required by postgre okay and if that so i have to ensure that when i provision a new postgraduate i have to ensure that the subnet exists before i can provision the uh before i can provision the postgre cluster okay so there is a dependency and there is an order in which you need to create things so you need to be aware that if you are breaking things apart into modules they uh you need to know that how they really get and fix themselves together to actually form environment okay well defined inputs and outputs for a module actually makes composable models so if if you are saying that i need input of something so in case of postgame cluster you say that i need an input in terms of which subnet and all those things and then there is a subnet module that actually gives you an output then it becomes like a composable thing then you essentially say that this guy is giving me these details which are the inputs to this particular model and then you can somehow combine them so even if those are two independent components they can be applied independently of each other they still are giving some way of some information hunting between them uh to essentially create the composible models so one egg one tool or one example of this is uh it's done uh something like in terra grant so this is a terra grant documentation okay so terah guarantees art is a tool on top of uh terraform research so what they are using here saying it they are saying that there is a back-end application which is a different component and front end is different noise can be different all these things are different okay but then now you are you can say that you can define dependencies like this okay ideally i would like to have versions here okay but that's what they are saying they probably also support version so i need to check that okay but they are essentially allowing you to see and specify dependencies between models which is not possible in pure terraform okay but this tool is allowing you to do that so now when you say that uh apply okay when you say run all and apply then it takes care of the dependencies as well so it basically understands that front end depends on back end for something then backhand depends on the radius radius also depends on back end also depends on the s12 and then they all depends on the vpc okay so that they understand this and then if you say that create a front-end app then it will also end up creating almost everything if it doesn't exist okay it will apply those things if it exists then it will not do anything there so that allows for that that tool is actually doing an orchestration for you so you have created different modules but it because you have created a kind of a dependency graph it understands that these are the things to be created otherwise if you don't know these dependencies then if i want to create the front-end app now it will fail probably because the radius is not there let's say or something is not there and then you have to provision that so you don't know so this is like a small graph but in reality you can have like big graph so you need to know you if you if you break things apart you need to know how they actually combine together to form a particular environment yeah so just the conclusion now so what we have here is use the right tool for the right job that's why we looked at the evolution of the tools and how the context actually changed certain tools they were very powerful earlier becomes awkward afterwards [Music] then follow the same ci cd practices for infra code so like code every configuration that we talked about we do that already for application code and we really understand that but when it comes to instructor code somehow i have seen people missing it uh completely as well then you end up with duplicate code or you end up with uh weird situations in which you have to make a promotion of the new version just to make a change in the configurations on all the things then reduce the drift between the code and the infrastructure so this is about making sure that you have some way of continuously applying the infrastructure code or at least have a mechanism to highlight that there is a gap okay so that you can do something about there are tools around this so there is something called as a drift ctl which which looks at the instructor and equivalence checks uh whether there is any difference in that and then it highlights that it can also send a notification on slack for example so those are the tools that you can check then the last one is keep the infrastructure module there while managing the orchestration so sometimes the dependency management can be as simple as you just noting it down saying that this comes first then this then this then this if it is simple enough small enough that works if it is like big enough then you have to be anything and you might need a tool you might need to create a tool or something like that yeah that's all i had for the talk are there any questions um does anyone have a question i do not have a question yeah does anyone else was it useful at least any feedback um i mean i liked it pretty much yeah it was really good for me um does anyone else have any feedback anything else to say anything that was not known to you and uh it was useful you probably can use it in your context of something uh hi question ravi here uh yeah so one question i have is uh so like here we prescribe to have a like uh uh to create the modules for different uh uh for different resources of the cloud but like how we uh how we develop them in in terms of uh having a tested uh tested resources because it might be that some some team is uh or maybe a part of the team members developing modules and somebody else is using right so i mean uh so if you have to like draw the problem what will be the testing strategy is that yes yeah so generally what happens is see uh the way infrastructure generally works is it gets combined with the environments of the development right so they have they have environments like their weighties and production ratio and infrastructure generally gets combined first time it gets combining detail then uat so it is sharing the same uh environments but generally what you should have is you should have a sandbox or something different where the application doesn't exist okay and that's where you can uh perform the deployments or or run the code against those environments and ensure that the test those are tested there so for example certain people actually use things like uh create or test so you have a test completely uh people actually use a completely different uh account for for that matter actually so you have a test account aws account where you create the infrastructure uh you test it so you write test around that and you say that okay this is accessible this is created this is up and running this is md all those things you say and then you completely destroy so things like uh cloud nuke or tools like this are actually used for this purpose so you destroy everything that is there in that test account okay and that's how you can actually test it so you need a separate environment which is not integrated with the uh with the uh devs so you need something like a sandbox which is completely owned by the devops team there is no application code running and then the next next uh environment is the dave employment where your code and the uh the developers or the application code runs together okay thanks thank you [Music] very good detailed session in other one says excellent session and yeah i mean most of the practices that you talked about are being used in the project that i am working on however i did not know why um they are this way because we have three different repositories one for code one for the infrastructure and third one is basically a combination of both where we have the module and we deployed modules yeah so i used to wonder why it is that way and yeah today this session helped me a lot knowing why it is the way it is yeah all right um thanks everyone for joining in i'll stop there thank you thanks a lot